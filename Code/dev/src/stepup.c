/*
 * stepup.c
 *
 *  Created on: 17-12-2014
 *      Author: Tomek
 */

#include <stm32l/rcc.h>
#include <stm32l/gpio.h>
#include <stm32l/timer.h>
#include <stm32l/adc.h>
#include <stm32l/dma.h>
#include <stm32l/nvic.h>
#include <util/elems.h>
#include <util/minmax.h>
#include <dev/stepup.h>
#include <sys/err.h>

#define DEBUG
#include <dev/debug.h>

/* adc samples buffer */
static uint16_t samples[32];
/* regulation */
static uint32_t reg;

/* dma channel 1 isr */
static void StepUp_Dmac1Isr(void)
{
	/* get status */
	uint16_t isr = DMA1->ISR;
	/* buffer pointer */
	uint16_t *ptr = samples, cnt;
	/* accumulator */
	uint32_t a = 0;

	/* re-enable dma if needed */
	DMAC1->CCR |= DMA_CCR_EN;
	/* clear interrupt flags */
	DMA1->IFCR = DMA_IFCR_CGIF1;

	/* got transfer complete? */
	if (isr & DMA_ISR_TCIF1) {
		/* select second half of measurement buffer */
		ptr = samples + elems(samples) / 2;
	}

	cnt = elems(samples) / 2;
	/* sum all measurements */
	while (cnt--) {
		a += *(ptr++);
	}

	/* get current error vector */
	int32_t diff = (a - 2900);
	/* get diff */
	diff = min(max(diff, -512), 512);

	/* voltage comparator */
	reg += diff;
	/* limit range (min 16us, max */
	reg = min(max(reg, (uint32_t)64 << 8), (uint32_t)240 << 8);

	/* apply regulation */
	TIM4->ARR = reg >> 8;
	/* set new sampling point */
	TIM4->CCR4 = (reg >> 9);
}

/* initialize step up converter */
int StepUp_Init(void)
{
	/* enable gpiob */
	RCC->AHBENR |= RCC_AHBENR_GPIOAEN | RCC_AHBENR_GPIOBEN |
			RCC_AHBENR_DMA1EN;
	/* enable timer */
	RCC->APB1ENR |= RCC_APB1ENR_TIM4EN;
	/* enable adc */
	RCC->APB2ENR |= RCC_APB2ENR_ADC1EN;

	/* initial regulator value (lowest allowable regulation) */
	reg = 240 << 8;

	/* reset prescaler */
	TIM4->PSC = 0;
	/* initial setup */
	TIM4->ARR = 100;
	/* configure pwm1 mode for channel 1 */
	TIM4->CCMR1 = TIM_CCMR1_OC1M_2 | TIM_CCMR1_OC1M_1;
	/* configure pwm mode 2 for channel 4, enable preload */
	TIM4->CCMR2 = TIM_CCMR2_OC4M | TIM_CCMR2_OC4PE;
	/* set pulse width */
	TIM4->CCR1 = 8;
	/* configure adc sampling point: right in the middle of pulses generated by
	 * cc1 */
	TIM4->CCR4 = TIM4->ARR / 100;
	/* enable adc trigger generation */
	TIM4->CCER |= TIM_CCER_CC4E;
	/* enable timer, ARR buffering is needed to be able to modify ARR on the go
	 * by regulation algorithm */
	TIM4->CR1 |= TIM_CR1_ARPE | TIM_CR1_CEN;

	/* prepare analog pin (pa1) */
	GPIOA->MODER |= GPIO_MODER_MODER1;

	/* configure pin */
	GPIOB->MODER &= ~GPIO_MODER_MODER6;
	/* select alternate function */
	GPIOB->AFRL |= GPIO_AF_TIM3_4 << 24;
	/* apply gpio configuration */
	GPIOB->MODER |= GPIO_MODER_MODER6_1;

	/* enable adc clock */
	ADC1->CR2 = ADC_CR2_ADON;
	/* synchronize domains */
	while ((ADC1->SR & ADC_SR_ADONS) == 0x00);
	/* single channel mode */
	ADC1->SQR1 = 0x00;

	/* select trigger channel: tim4 cc4, enable dma requests */
	ADC1->CR2 |= ADC_CR2_EXTSEL_2 | ADC_CR2_EXTSEL_0 | ADC_CR2_DMA |
			ADC_CR2_DDS;
	/* select channel: ain1 (pa1) */
	ADC1->SQR5 = 0x01;

	/* configure dma, data width 16 bit, read from peripheral, circ buf, half
	 * transfer interrupt, transfer interrupt */
	DMAC1->CCR = DMA_CCR_PL | DMA_CCR_MSIZE_0 | DMA_CCR_PSIZE_0 |
			DMA_CCR_MINC | DMA_CCR_CIRC | DMA_CCR_HTIE | DMA_CCR_TCIE;
	/* set data source */
	DMAC1->CPAR = (uint32_t)&ADC1->DR;
	/* set data destination */
	DMAC1->CMAR = (uint32_t)samples;
	/* set number of transfers */
	DMAC1->CNDTR = elems(samples);

	/* prepare interrupt routine for half-transfer and transfer complete */
	NVIC_SetInterruptVector(NVIC_DMA1, StepUp_Dmac1Isr);
	/* set priority */
	NVIC_SetInterruptPriority(NVIC_DMA1, 0);
	/* enable interrupt */
	NVIC_EnableInterrupt(NVIC_DMA1);

	/* enable dma */
	DMAC1->CCR |= DMA_CCR_EN;
	/* enable trigger detection on cc4 rising edge */
	ADC1->CR2 |= ADC_CR2_EXTEN_0;

	/* enable step up */
	StepUp_Cmd(1);

	/* report status */
	return EOK;
}

/* deinitialize step up converter */
int StepUp_Deinit(void)
{
	/* stop timer */
	TIM4->CR1 = 0;
	/* disable timer pin */
	GPIOB->MODER |= GPIO_MODER_MODER6;

	/* disable adc clock */
	ADC1->CR2 &= ~ADC_CR2_ADON;
	/* synchronize domains */
	while (ADC1->SR & ADC_SR_ADONS);

	/* disable timer clock */
	RCC->APB1ENR &= ~RCC_APB1ENR_TIM4EN;
	/* disable adc and timer */
	RCC->APB2ENR &= ~RCC_APB2ENR_ADC1EN;

	/* report status */
	return EOK;
}

/* enable/disable step up converter */
void StepUp_Cmd(uint8_t state)
{
	/* output enable bit */
	bitband_t oce = BITBAND_PERIPH(&TIM4->CCER, 0);
	/* timer enable bit */
	bitband_t cen = BITBAND_PERIPH(&TIM4->CR1, 0);

	/* apply new state */
	*cen = *oce = state != 0;
}
